//+------------------------------------------------------------------+
//|                                     MeanSnapper_Pro_Safety_v5.mq5|
//|                                  Copyright 2026, AI Collaborator |
//+------------------------------------------------------------------+
#property strict
#include <Trade\Trade.mqh>

// --- Strategy Inputs ---
input int      InpBBLength    = 20;          
input double   InpBBMult      = 2.0;         
input int      InpRSILevel    = 14;          
input int      InpRSISell     = 30; // Buy when RSI < 30
input int      InpRSIOver     = 70; // Sell when RSI > 70
input double   InpLotSize     = 0.02;        
input int      InpMagicNum    = 123456;      

// --- Safety & Risk Management ---
input int      InpStopLossPips = 50;         // Hard Stop Loss in Pips
input double   InpMaxDrawdown  = 5.0;        // Close all if account drops 5%
input int      InpHeartbeatHrs = 4;          

// --- Global Variables ---
int      handleBB, handleRSI;
CTrade   trade;
datetime lastBarTime = 0; 
datetime lastHeartbeat = 0;

//+------------------------------------------------------------------+
int OnInit()
{
   handleBB  = iBands(_Symbol, _Period, InpBBLength, 0, InpBBMult, PRICE_CLOSE);
   handleRSI = iRSI(_Symbol, _Period, InpRSILevel, PRICE_CLOSE);
   
   trade.SetExpertMagicNumber(InpMagicNum);
   EventSetTimer(60); 

   SendNotification("üõ°Ô∏è Mean Snapper PRO Active | StopLoss: " + (string)InpStopLossPips + " pips");
   return(INIT_SUCCEEDED);
}

void OnDeinit(const int reason) { EventKillTimer(); }

//+------------------------------------------------------------------+
//| Main Execution Logic                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   // 1. EMERGENCY DRAWDOWN CHECK
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   if(equity < balance * (1 - (InpMaxDrawdown / 100)))
   {
      trade.PositionCloseAll();
      SendNotification("üö® EMERGENCY: Max Drawdown Hit. System Halted.");
      ExpertRemove(); // Turns the bot off for safety
      return;
   }

   // 2. ONE TRADE PER CANDLE & CHECK IF POSITION OPEN
   datetime currentBar = iTime(_Symbol, _Period, 0);
   if(PositionSelectByMagic(InpMagicNum)) return; // Strictly 1 trade at a time
   if(currentBar == lastBarTime) return; // Wait for the candle to close

   // 3. GATHER DATA
   double upper[], lower[], rsi[];
   ArraySetAsSeries(upper, true); ArraySetAsSeries(lower, true); ArraySetAsSeries(rsi, true);
   
   if(CopyBuffer(handleBB, 1, 0, 2, upper) < 0 || 
      CopyBuffer(handleBB, 2, 0, 2, lower) < 0 || 
      CopyBuffer(handleRSI, 0, 0, 2, rsi) < 0) return;

   double closePrice = iClose(_Symbol, _Period, 0);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);

   // 4. ENTRY LOGIC
   // LONG: Price < Lower Band AND RSI < 30
   if(closePrice < lower[0] && rsi[0] < InpRSISell)
   {
      double sl = closePrice - (InpStopLossPips * 10 * point); // Calculate SL
      if(trade.Buy(InpLotSize, _Symbol, SymbolInfoDouble(_Symbol, SYMBOL_ASK), sl, 0, "Snapper Long"))
      {
         lastBarTime = currentBar;
         SendNotification("üöÄ BUY: RSI " + DoubleToString(rsi[0], 1) + " | SL set at " + (string)InpStopLossPips + " pips");
      }
   }

   // SHORT: Price > Upper Band AND RSI > 70
   if(closePrice > upper[0] && rsi[0] > InpRSIOver)
   {
      double sl = closePrice + (InpStopLossPips * 10 * point); // Calculate SL
      if(trade.Sell(InpLotSize, _Symbol, SymbolInfoDouble(_Symbol, SYMBOL_BID), sl, 0, "Snapper Short"))
      {
         lastBarTime = currentBar;
         SendNotification("üìâ SELL: RSI " + DoubleToString(rsi[0], 1) + " | SL set at " + (string)InpStopLossPips + " pips");
      }
   }
}

//+------------------------------------------------------------------+
//| Exit Logic (Mean Reversion to Middle Band)                       |
//+------------------------------------------------------------------+
bool PositionSelectByMagic(long magic)
{
   for(int i=PositionsTotal()-1; i>=0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket) && PositionGetInteger(POSITION_MAGIC) == magic)
      {
         double middle[];
         ArraySetAsSeries(middle, true);
         CopyBuffer(handleBB, 0, 0, 1, middle);
         
         double currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
         long type = PositionGetInteger(POSITION_TYPE);
         
         // Exit if it hits the "Mean" (Middle Band)
         if((type == POSITION_TYPE_BUY && currentPrice >= middle[0]) ||
            (type == POSITION_TYPE_SELL && currentPrice <= middle[0]))
         {
            trade.PositionClose(ticket);
            SendNotification("‚úÖ Target Reached: Middle Band.");
            return false;
         }
         return true;
      }
   }
   return false;
}

void OnTimer()
{
   datetime now = TimeCurrent();
   if(now - lastHeartbeat >= (InpHeartbeatHours * 3600))
   {
      SendStatusUpdate("Periodic Heartbeat");
      lastHeartbeat = now;
   }
}

void SendStatusUpdate(string reason)
{
   string msg = StringFormat("üíì %s\nEquity: $%.2f\nFloat: $%.2f", 
                             reason, AccountInfoDouble(ACCOUNT_EQUITY), AccountInfoDouble(ACCOUNT_PROFIT));
   SendNotification(msg);
}